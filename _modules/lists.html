
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>lists &mdash; beliefs 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="beliefs 1.0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">beliefs 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for lists</h1><div class="highlight"><pre>
<span class="kn">from</span> <span class="nn">cell</span> <span class="kn">import</span> <span class="o">*</span>

<div class="viewcode-block" id="LinearOrderedCell"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell">[docs]</a><span class="k">class</span> <span class="nc">LinearOrderedCell</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generalization of IntervalCell to non-numeric symbols</span>

<span class="sd">    :param ordered_domain: An ordered sequence of symbols. Must not contain duplicate entries.</span>
<span class="sd">    :type ordered_domain: list</span>
<span class="sd">    :param low,high: Symbols in the domain that mark the lower and upper bounds</span>
<span class="sd">    :raises: CellConstructionFailure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ordered_domain</span><span class="p">,</span> <span class="n">low</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">          - ordered_domain:  an ordered sequence of symbols</span>
<span class="sd">          - low: a symbol in the domain that marks the lower bound</span>
<span class="sd">          - high: a symbol in the domain that marks the upper bound</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ordered_domain</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CellConstructionFailure</span><span class="p">(</span><span class="s">&quot;Ordered domain must be a list, with fixed order&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ordered_domain</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">ordered_domain</span><span class="p">)):</span>
            <span class="c"># duplicate entries</span>
            <span class="k">raise</span> <span class="n">CellConstructionFailure</span><span class="p">(</span><span class="s">&quot;All elements of the domain need unique hash&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">ordered_domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low</span> <span class="o">=</span> <span class="n">low</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">high</span>

        <span class="c"># sanity checks</span>
        <span class="k">if</span> <span class="n">low</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">low</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span> 
            <span class="k">raise</span> <span class="n">CellConstructionFailure</span><span class="p">(</span><span class="s">&quot;Value low=&#39;</span><span class="si">%s</span><span class="s">&#39; not in domain.&quot;</span> \
              <span class="o">%</span> <span class="p">(</span><span class="n">low</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">high</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">high</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">high</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CellConstructionFailure</span><span class="p">(</span><span class="s">&quot;Value high=&#39;</span><span class="si">%s</span><span class="s">&#39; not in domain.&quot;</span> \
                        <span class="o">%</span> <span class="p">(</span><span class="n">high</span><span class="p">))</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">high</span><span class="p">),</span> \
                <span class="s">&quot;Lower bound must be &lt;= upper &quot;</span>

<div class="viewcode-block" id="LinearOrderedCell.stem"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell.stem">[docs]</a>    <span class="k">def</span> <span class="nf">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a new instance without any values</span>

<span class="sd">        :returns: LinearOrderedCell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LinearOrderedCell.coerce"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell.coerce">[docs]</a>    <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Takes one or more values in the domain and returns a LinearOrderedCell with that domain. If the input is a single value, the low and high bounds will both be set to that value. If the input is a list or a tuple, the low and high bounds will be set to the min and max elements of the list or tuple. </span>

<span class="sd">        .. note::</span>
<span class="sd">            Unlike the ``coerce`` methods in many of the other modules, this is **not** a static method.</span>

<span class="sd">        :param value: A single value in the domain, or a list or tuple of values in the domain</span>
<span class="sd">        :returns: LinearOrderedCell</span>
<span class="sd">        :raises: Exception</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">LinearOrderedCell</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">==</span> <span class="n">value</span><span class="o">.</span><span class="n">domain</span> <span class="ow">or</span> \
            <span class="n">list_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]):</span>
            <span class="c"># is LinearOrderedCell with same domain</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">LinearOrderedCell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">value</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">LinearOrderedCell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">LinearOrderedCell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sorted_vals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_i</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">LinearOrderedCell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">sorted_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sorted_vals</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Cannot coerce </span><span class="si">%s</span><span class="s"> into LinearOrderedCell&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
</div>
<div class="viewcode-block" id="LinearOrderedCell.to_i"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell.to_i">[docs]</a>    <span class="k">def</span> <span class="nf">to_i</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Maps value to position in domain</span>

<span class="sd">        :param val: value in the domain</span>
<span class="sd">        :returns: int -- index of value in the domain. Returns -1 if val is None</span>

<span class="sd">        &gt;&gt;&gt; v = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;animal&#39;, &#39;toy poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; v.to_i(&#39;dog&#39;)</span>
<span class="sd">        1</span>
<span class="sd">        &gt;&gt;&gt; v.to_i(&#39;toy poodle&#39;)</span>
<span class="sd">        3</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LinearOrderedCell.is_contradictory"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell.is_contradictory">[docs]</a>    <span class="k">def</span> <span class="nf">is_contradictory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether other and self can coexist. Two LinearOrderedCells are contradictory if there is on overlap between their boundaries.</span>

<span class="sd">        :param other: A LinearOrderedCell or coercible value</span>
<span class="sd">        :returns: bool</span>
<span class="sd">        :raises: Exception</span>

<span class="sd">        &gt;&gt;&gt; x = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;animal&#39;, &#39;dog&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;animal&#39;, &#39;toy poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; z = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;poodle&#39;, &#39;toy poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_contradictory(z)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt; x.is_contradictory(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; y.is_contradictory(z)</span>
<span class="sd">        False</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">to_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_i</span>
        <span class="k">assert</span> <span class="n">to_i</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">low</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">to_i</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">high</span><span class="p">),</span> <span class="s">&quot;Low must be &lt;= high&quot;</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">to_i</span><span class="p">,</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">]))</span> <span class="o">&lt;=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">to_i</span><span class="p">,</span> <span class="p">[</span><span class="n">other</span><span class="o">.</span><span class="n">high</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high</span><span class="p">])):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="LinearOrderedCell.is_entailed_by"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell.is_entailed_by">[docs]</a>    <span class="k">def</span> <span class="nf">is_entailed_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if Other is more specific than self or if Other is bounded within self.</span>

<span class="sd">        :param other: A LinearOrderedCell or coercible value</span>
<span class="sd">        :returns: bool</span>
<span class="sd">        :raises: Exception</span>

<span class="sd">        &gt;&gt;&gt; x = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;animal&#39;, &#39;poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;dog&#39;, &#39;dog&#39;)</span>
<span class="sd">        &gt;&gt;&gt; z = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;poodle&#39;, &#39;toy poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_entailed_by(z)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x.is_entailed_by(y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; y.is_entailedy_by(x)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; z.is_entailed_by(y)</span>
<span class="sd">        False</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">to_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_i</span>
        <span class="k">return</span> <span class="n">to_i</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">low</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">to_i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">)</span> <span class="ow">and</span> \
                <span class="n">to_i</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">high</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">to_i</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">high</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="LinearOrderedCell.is_equal"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell.is_equal">[docs]</a>    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines whether two intervals are the same, i.e. every element of each domain is also an element of the other domain, and the low and high of each domain correspond to the low and high of the other</span>

<span class="sd">        :param other: A LinearOrderedCell or coercible value</span>
<span class="sd">        :returns: bool</span>
<span class="sd">        :raises: Exception</span>

<span class="sd">        &gt;&gt;&gt; x = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;animal&#39;, &#39;poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;], &#39;dog&#39;, &#39;dog&#39;)</span>
<span class="sd">        &gt;&gt;&gt; z = LinearOrderedCell([&#39;dog&#39;,&#39;toy poodle&#39;,&#39;animal&#39;,&#39;poodle&#39;], &#39;animal&#39;, &#39;poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.is_equal(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x.is_equal(z)</span>
<span class="sd">        True</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">low</span> \
                <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">high</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">high</span>
</div>
    <span class="sd">&#39;&#39;&#39;def to_dot(self):</span>
<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        A string representation of the Cell</span>

<span class="sd">        :returns: If the domain consists of a single value, that value is returned. Otherwise, the empty string is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
<span class="sd">        if self.low == self.high:</span>
<span class="sd">            return self.low</span>
<span class="sd">        else:</span>
<span class="sd">            return &quot;&quot;&#39;&#39;&#39;</span>

<div class="viewcode-block" id="LinearOrderedCell.merge"><a class="viewcode-back" href="../lists.html#lists.LinearOrderedCell.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges the two values</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method **will** modify the *self* parameter</span>

<span class="sd">        :param other: A LinearOrderedCell or coercible value</span>
<span class="sd">        :returns: LinearOrderedCell</span>
<span class="sd">        :raises: Exception, Contradiction</span>

<span class="sd">        &gt;&gt;&gt; x = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;animal&#39;, &#39;poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; y = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;dog&#39;, &#39;poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; z = LinearOrderedCell([&#39;animal&#39;,&#39;dog&#39;,&#39;poodle&#39;,&#39;toy poodle&#39;], &#39;poodle&#39;, &#39;toy poodle&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x.merge(y)</span>
<span class="sd">        [dog,poodle]</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        [dog, poodle]</span>
<span class="sd">        &gt;&gt;&gt; x.merge(z)</span>
<span class="sd">        [poodle,poodle]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">list_diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">domain</span><span class="p">)</span> <span class="o">!=</span> <span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Incomparable orderings. Different domains&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c"># pick among dependencies</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">is_entailed_by</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_entailed_by</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">high</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_contradictory</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Contradiction</span><span class="p">(</span><span class="s">&quot;Cannot merge </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># information in both</span>
            <span class="n">to_i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_i</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">low</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">to_i</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">low</span><span class="p">]))]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">high</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">to_i</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">high</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">high</span><span class="p">]))]</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">hash</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Displays the range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s">&quot;[</span><span class="si">%s</span><span class="s">, </span><span class="si">%s</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">high</span><span class="p">)</span>

    <span class="n">__eq__</span> <span class="o">=</span> <span class="n">is_equal</span>

</div>
<div class="viewcode-block" id="PrefixCell"><a class="viewcode-back" href="../lists.html#lists.PrefixCell">[docs]</a><span class="k">class</span> <span class="nc">PrefixCell</span><span class="p">(</span><span class="n">Cell</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PrefixCells contain ordered elements</span>

<span class="sd">    :param value: Optional parameter specifying initial list. Defaults to the empty list.</span>
<span class="sd">    :type value: list</span>
<span class="sd">    :raises: CellContstructionFailure</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new PrefixCell, optionally with an initial value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CellConstructionFailure</span><span class="p">(</span><span class="s">&quot;PrefixCells must be given a list&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="PrefixCell.coerce"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.coerce">[docs]</a>    <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Turns a value into a PrefixCell</span>

<span class="sd">        :param value: The value to be coerced</span>
<span class="sd">        :type value: list, PrefixCell</span>
<span class="sd">        :returns: PrefixCell</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">PrefixCell</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">PrefixCell</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">PrefixCell</span><span class="p">([</span><span class="n">value</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="PrefixCell.size"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of elements in the list</span>

<span class="sd">        :returns: int -- number of elements in the list</span>

<span class="sd">        &gt;&gt;&gt; x = PrefixCell([&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.size()</span>
<span class="sd">        3</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrefixCell.is_contradictory"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.is_contradictory">[docs]</a>    <span class="k">def</span> <span class="nf">is_contradictory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Two lists are contradictory if the shorter one is not a prefix of the</span>
<span class="sd">        other. (Very strict definition -- could be generalized to subsequence) It does not matter whether *self* or *other* is the shorter one.</span>

<span class="sd">        Empty lists are never contradictory.</span>

<span class="sd">        :param other: The PrefixCell to test</span>
<span class="sd">        :type other: list</span>
<span class="sd">        :returns: bool</span>

<span class="sd">        &gt;&gt;&gt; x = PrefixCell([1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; y = PrefixCell([1,2])</span>
<span class="sd">        &gt;&gt;&gt; z = PrefixCell([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.is_contradictory(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; y.is_contradictory(z)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; z.is_contradictory(PrefixCell([]))</span>
<span class="sd">        False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">is_contradictory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c"># ensure self is bigger or equal size</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># empty lists are fine</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="c"># see if any values in the shorter list are contradictory or </span>
        <span class="c"># unequal</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">oval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&#39;is_contradictory&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                    <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_contradictory</span><span class="p">(</span><span class="n">oval</span><span class="p">):</span>
                <span class="c"># allow comparing cells</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">oval</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>
</div>
<div class="viewcode-block" id="PrefixCell.is_entailed_by"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.is_entailed_by">[docs]</a>    <span class="k">def</span> <span class="nf">is_entailed_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True iff the values in this list can be entailed by the other</span>
<span class="sd">        list (ie, this list is a prefix of the other)</span>

<span class="sd">        :param other: PrefixCell or coercible value</span>
<span class="sd">        :returns: bool</span>

<span class="sd">        &gt;&gt;&gt; x = PrefixCell([&#39;red&#39;,&#39;orange&#39;,&#39;yellow&#39;])</span>
<span class="sd">        &gt;&gt;&gt; y = PrefixCell([&#39;red&#39;,&#39;orange&#39;,&#39;yellow&#39;,&#39;green&#39;,&#39;blue&#39;,&#39;indigo&#39;,&#39;violet&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.is_entailed_by(y)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; y.is_entailed_by(x)</span>
<span class="sd">        False</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">():</span>
            <span class="c"># other is bigger, can&#39;t be entailed</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># list is empty</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c"># see if any values in the shorter list are contradictory or </span>
        <span class="c"># unequal</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">oval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&#39;is_entailed_by&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_entailed_by</span><span class="p">(</span><span class="n">oval</span><span class="p">):</span>
                <span class="c"># compare cells</span>
                <span class="k">return</span> <span class="bp">False</span> 
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">oval</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span> 
        <span class="k">return</span> <span class="bp">True</span> 
        </div>
<div class="viewcode-block" id="PrefixCell.is_equal"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.is_equal">[docs]</a>    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the lists are equal</span>

<span class="sd">        :param other: The value or PrefixCell to test</span>
<span class="sd">        :returns: bool</span>

<span class="sd">        &gt;&gt;&gt; x = PrefixCell([1,2])</span>
<span class="sd">        &gt;&gt;&gt; y = PrefixCell([2,1])</span>
<span class="sd">        &gt;&gt;&gt; x.is_equal(y)</span>
<span class="sd">        False</span>
<span class="sd">        &gt;&gt;&gt; x.is_equal([1,2])</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">oval</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&#39;is_equal&#39;</span><span class="p">)</span> <span class="ow">and</span> \
                   <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="n">oval</span><span class="p">):</span>
                <span class="c"># compare cells</span>
                <span class="k">return</span> <span class="bp">False</span> 
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">oval</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span> 
        <span class="k">return</span> <span class="bp">True</span> 
        </div>
<div class="viewcode-block" id="PrefixCell.merge"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.merge">[docs]</a>    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merges two Lists.</span>

<span class="sd">        .. note::</span>
<span class="sd">            This method **will** modify the *self* parameter.</span>

<span class="sd">        :param other: A PrefixCell or coercible value</span>
<span class="sd">        :returns: PrefixCell</span>
<span class="sd">        :raises: Contradiction</span>

<span class="sd">        &gt;&gt;&gt; x = PrefixCell([1,2])</span>
<span class="sd">        &gt;&gt;&gt; y = PrefixCell([1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; z = x.merge(y)</span>
<span class="sd">        &gt;&gt;&gt; z</span>
<span class="sd">        [1,2,3]</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        [1,2,3]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_equal</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="c"># pick among dependencies</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="n">other</span><span class="o">.</span><span class="n">is_entailed_by</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_entailed_by</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">[:]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_contradictory</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">Contradiction</span><span class="p">(</span><span class="s">&quot;Cannot merge list &#39;</span><span class="si">%s</span><span class="s">&#39; with &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> \
                    <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">value</span><span class="p">[:]</span>
            <span class="c"># otherwise, return self</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="PrefixCell.append"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">el</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Idiosynractic method for adding an element to a list. Modifies the *self* parameter.</span>

<span class="sd">        &gt;&gt;&gt; x = PrefixCell([&#39;a&#39;,&#39;b&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.append(&#39;c&#39;)</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        [a,b,c]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="PrefixCell.get_values"><a class="viewcode-back" href="../lists.html#lists.PrefixCell.get_values">[docs]</a>    <span class="k">def</span> <span class="nf">get_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list containing the elements.</span>

<span class="sd">        :returns: list</span>

<span class="sd">        &gt;&gt;&gt; x = PrefixCell([&#39;big&#39;,&#39;blue&#39;,&#39;ball&#39;])</span>
<span class="sd">        &gt;&gt;&gt; x.get_values()</span>
<span class="sd">        [&#39;big&#39;,&#39;blue&#39;,&#39;ball&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">[:]</span>
</div>
    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">hash</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">^</span> <span class="nb">hash</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;[&#39;</span> <span class="o">+</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">])</span> <span class="o">+</span> <span class="s">&#39;]&#39;</span>

    <span class="n">__str__</span> <span class="o">=</span> <span class="n">__repr__</span>
    <span class="n">__eq__</span> <span class="o">=</span> <span class="n">is_equal</span>

</div>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">LinearOrderedCell</span><span class="p">([</span><span class="s">&#39;animal&#39;</span><span class="p">,</span><span class="s">&#39;dog&#39;</span><span class="p">,</span><span class="s">&#39;poodle&#39;</span><span class="p">,</span><span class="s">&#39;toy poodle&#39;</span><span class="p">],</span> <span class="s">&#39;animal&#39;</span><span class="p">,</span> <span class="s">&#39;toy poodle&#39;</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">LinearOrderedCell</span><span class="p">([</span><span class="s">&#39;animal&#39;</span><span class="p">,</span><span class="s">&#39;dog&#39;</span><span class="p">,</span><span class="s">&#39;poodle&#39;</span><span class="p">,</span><span class="s">&#39;toy poodle&#39;</span><span class="p">],</span> <span class="s">&#39;dog&#39;</span><span class="p">,</span> <span class="s">&quot;toy poodle&quot;</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">LinearOrderedCell</span><span class="p">([</span><span class="s">&#39;animal&#39;</span><span class="p">,</span><span class="s">&#39;dog&#39;</span><span class="p">,</span><span class="s">&#39;poodle&#39;</span><span class="p">,</span><span class="s">&#39;toy poodle&#39;</span><span class="p">],</span> <span class="s">&#39;animal&#39;</span><span class="p">,</span> <span class="s">&#39;poodle&#39;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">LinearOrderedCell</span><span class="p">([</span><span class="s">&#39;animal&#39;</span><span class="p">,</span><span class="s">&#39;dog&#39;</span><span class="p">,</span><span class="s">&#39;poodle&#39;</span><span class="p">,</span><span class="s">&#39;toy poodle&#39;</span><span class="p">],</span> <span class="s">&#39;dog&#39;</span><span class="p">,</span> <span class="s">&#39;dog&#39;</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">LinearOrderedCell</span><span class="p">([</span><span class="s">&#39;animal&#39;</span><span class="p">,</span><span class="s">&#39;dog&#39;</span><span class="p">,</span><span class="s">&#39;poodle&#39;</span><span class="p">,</span><span class="s">&#39;toy poodle&#39;</span><span class="p">],</span> <span class="s">&#39;poodle&#39;</span><span class="p">,</span> <span class="s">&#39;toy poodle&#39;</span><span class="p">)</span>

    <span class="n">vpc</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span><span class="s">&quot;d&quot;</span><span class="p">])</span>
    <span class="n">wpc</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">xpc</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">ypc</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="p">([</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span><span class="s">&quot;c&quot;</span><span class="p">])</span>
    <span class="n">zpc</span> <span class="o">=</span> <span class="n">PrefixCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../index.html">beliefs 1.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Dustin Smith, Nicolas Bravo.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>